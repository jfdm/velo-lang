%TODO: comment on cost of thinning as inductive values?
%      cite the preprint solving this & whose diagram this is?
\input{ast}

Now that our core language is well scoped by construction, our compiler passes
need to be proven scope-preserving.
%
This is not a new requirement, merely the explicitation of a constraint that
used to be enforced informally.


The purpose of common sub-expressions elimination is to identify subterms
that appear multiple times in the syntax tree and abstract over them so
as to avoid needless recomputations at runtime.
%
In the following example for instance, we would like to let-bind $t$ before
the application node (denoted \$) so that it may be shared by both subtrees.

\cseexamplegraph{}

One of the challenge of CSE exemplified above is that the term of interest
may be burried deep inside separate contexts. In our intrinsically scoped
representation, $t$ in scope $\Gamma, x : \sigma$ is potentially not actually
syntactically equal to a copy living in $\Gamma, a : \tau, b : \nu$.
%
Indeed a variable $v$ bound in $\Gamma$ will for instance be represented by
the \DeBruijn{} index ($1+v$) in $\Gamma, x : \sigma$
but the index ($2+v$) in $\Gamma, a :  \tau, b : \nu$.

If only terms were indexed by their exact \emph{support}! We would not care
about additional yet irrelevant variables that happen to be in scope.
%
The principled solution here is to switch to a different representation for
the purpose of common sub-expression elimination: the co-\DeBruijn{}
representation~\cite{DBLP:journals/corr/abs-1807-04085} provides exactly this guarantee.

%\subsection{Co-\DeBruijn{} representation}

In the co-\DeBruijn{} representation, every term is precisely indexed by its
exact support.
%
That is to say that every subterm explicitly throws away the bound variables
that are not mentioned in it.
%
By the time we reach a variable node, a single  bound variable remains in scope:
precisely the one being referred to.

If we think of thinnings as sequences of 0/1 bits stating whether a variable
is kept or dropped, and admitting that such sequences can be represented as
list of either $\bullet$ (1) or $\circ$ (0), the $S$ combinator
($\lambda g. \lambda f. \lambda x. g x (f x)$) is represented as follows in
co-\DeBruijn{} notation.

\codebruijnexamplegraph{}

The first three $\lambda$ abstractions only use $\bullet$ in their thinnings
because all of $g$, $f$, and $x$ do appear in the body of the combinator.
%
The first application node then splits the context into two: the first subterm
($g x$) drops $f$ while the second ($f x$) gets rid of $g$.
%
Further application nodes select the one variable still in scope for each
leaf subterm, respectively $g$, $x$, $f$, and $x$.


Using a co-\DeBruijn{} representation, we can easily identify shared subterms:
they need to not be mentioning any of the most local variables and be
syntactically equal.
